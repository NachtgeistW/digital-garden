## 一、算法

### 排序算法最快的是哪种

一般情况下最快的是快速排序和堆排序。平均情况下时间复杂度为O(nlogn)，最坏情况下时间复杂度为O(n^2)。此外，如果数据量较小，插入排序的效率可能会更高，因为它在处理小规模数据时有着较佳的表现。但是在处理大规模数据时，快速排序是通常的首选。

### 快速排序的时间复杂度是多少，怎样计算

在快速排序中，每次选取一个数作为基准（pivot），然后将小于等于基准的数放在左边，大于基准的数放在右边，再分别对左右两个子序列递归地进行排序。在最坏情况下，每次选取的基准都是当前子序列中的最小或最大值，这时时间复杂度会达到O(n^2)。但是在平均情况下，每次选取的基准都是随机的，此时时间复杂度可以达到O(nlogn)。

具体地，假设要排序的序列长度为n，快速排序的时间复杂度可以用递归树来表示。递归树的根节点表示对整个序列进行一次快排，左右子树分别表示对基准左边和右边的子序列进行排序。设左子树和右子树的节点数分别为n1和n2，则递归树的深度为log(n)，每层的时间复杂度为O(n)，因此快速排序的时间复杂度可以表示为O(nlogn)。

### 深度优先和广度优先搜索算法，哪个用队列，哪个用栈

深度优先搜索通常使用栈来实现，而广度优先搜索则使用队列来实现。

深度优先搜索（DFS）的思想是优先遍历尽可能深的节点，这就涉及到递归和回溯的概念。在搜索的过程中，每次访问一个节点时，就将该节点的后继节点（即子节点或相邻节点）压入栈中，然后访问栈顶元素，并将其弹出栈，继续遍历它的后继节点，直到找到所需的节点或遍历完所有节点。

广度优先搜索（BFS）则是从起始节点开始，逐层遍历其周围的节点，先访问距离起始节点为1的节点，再访问距离起始节点为2的节点，以此类推，直到找到目标节点或遍历完所有节点。在搜索的过程中，每次访问一个节点时，就将该节点的后继节点（即子节点或相邻节点）加入队列尾部，并将队列头部元素弹出，继续遍历队列中的下一个元素。

因此，深度优先搜索需要回溯和递归的支持，使用栈可以更好地实现这一过程；而广度优先搜索则需要按层遍历节点，使用队列可以更好地实现这一过程。

### 怎样检测一个链表是否存在循环

要检测一个链表是否存在循环，可以使用快慢指针的方法。具体做法是，定义两个指针 slow 和 fast，开始时它们都指向链表的头结点。然后，每次让 slow 向前移动一个节点，让 fast 向前移动两个节点，直到 fast 到达链表的末尾或者 fast 指向了一个已经访问过的节点（即出现了循环）。如果链表不存在循环，那么 fast 最终会到达链表的末尾，这时循环结束；如果链表存在循环，那么 fast 最终会在某个时刻与 slow 相遇，也就是说，两个指针在同一个节点处相遇了。

`public bool HasCycle(ListNode head) {`

    `if (head == null || head.next == null) {`

        `return false;`

    `}`

    `ListNode slow = head, fast = head.next;`

    `while (fast != null && fast.next != null) {`

        `if (slow == fast) {`

            `return true;`

        `}`

        `slow = slow.next;`

        `fast = fast.next.next;`

    `}`

    `return false;`

`}`

其中，ListNode 表示链表的节点，包含一个整型值 val 和一个指向下一个节点的指针 next。

### 有限状态机的应用

以下是一些有限状态机的应用举例：

1. 语法分析器：编译器通常使用有限状态机来对代码进行语法分析，以确定代码是否符合语言规范。
2. 自动机：自动机是一种可以接受特定语言的有限状态机。自动机在计算机科学中有很多应用，例如文本搜索、模式匹配、语言翻译等。
3. 电子电路设计：在数字电路中，有限状态机被用于设计和实现序列逻辑电路，如计数器、寄存器和状态机等。
4. 状态转移系统：状态转移系统用于建模计算机程序中的状态和状态之间的转换。它被广泛应用于软件开发和计算机网络中的协议分析和设计。
5. 游戏开发：游戏中的AI、NPC、任务等都可以用有限状态机来描述。
6. 自动驾驶：自动驾驶车辆中，有限状态机可以用于描述车辆状态、驾驶员行为和其他环境变量，并生成决策，例如刹车或转向。

总之，有限状态机是一种非常有用的模型，它能够简化问题，提高效率，并在许多领域提供了实际解决方案。

### 正则表达式中有限状态机的应用

在正则表达式中，有限状态机通常用于解析和匹配文本字符串。正则表达式可以描述字符串模式，例如电话号码、邮件地址、URL 等等。为了实现这些模式的匹配，正则表达式通常被编译成一个有限状态机，该有限状态机可以在文本字符串中搜索匹配模式。

正则表达式的有限状态机通常由以下几种状态组成：

- 初始状态：开始状态，也称为开始状态。
- 接受状态：最终状态，也称为结束状态或接受状态。
- 中间状态：处理字符串的状态，通常是一个或多个中间状态。

有限状态机可以实现基本的匹配和搜索功能，例如匹配单个字符或字符串，查找子串，以及在文本中查找模式的所有实例。正则表达式还支持更高级别的匹配功能，例如使用通配符、分组和替换。

### 行为树

[AI - Behaviour Trees](onenote:..\课程\进阶游戏技术.one#AI%20-%20Behaviour%20Trees&section-id={B57CCBB0-DE30-434E-8F1F-84134F749776}&page-id={206E7E7A-000D-42A3-89AA-7B881AA4A1AE}&end&base-path=https://d.docs.live.net/0f359644d54234c1/文档/轮%20的笔记本)

### A*寻路

[AI - Path Finding](onenote:..\课程\进阶游戏技术.one#AI%20-%20Path%20Finding&section-id={B57CCBB0-DE30-434E-8F1F-84134F749776}&page-id={DABBB9FA-96F3-4E9B-A4B5-EE0F0977CDA6}&end&base-path=https://d.docs.live.net/0f359644d54234c1/文档/轮%20的笔记本)

## 二、系统

### 进程和线程的区别

在操作系统中，进程和线程都是用于执行程序的基本执行单元。它们的主要区别在于它们是如何分配资源和管理内存的。

进程是指一个正在执行的程序实例，它包含了代码、数据、堆栈等资源。每个进程都有自己的地址空间、内存、文件句柄等系统资源。进程之间相互独立，它们不会共享内存和其他资源，通信和同步需要使用进程间通信（IPC）机制，如管道、消息队列、信号量等。

线程是进程内的一个执行单元，它与其他线程共享进程的地址空间、文件句柄等资源，它们可以访问同一内存区域和全局变量。线程之间通信和同步相对简单，可以直接使用共享内存、信号量、互斥锁等机制，而不需要通过操作系统提供的进程间通信机制。

因为线程可以共享进程的资源，所以相比进程创建和切换，线程的创建和切换代价更小，执行速度更快。此外，线程还可以充分利用多核CPU的并行性，提高系统的吞吐量和响应速度。

总之，进程和线程都是用于执行程序的基本执行单元，它们之间的区别在于资源的分配和管理方式。进程之间相互独立，需要通过IPC进行通信和同步；而线程共享进程的资源，通信和同步相对简单。

### 进程间数据通讯的方式：管道、Socket、消息队列、共享内存

在操作系统中，进程（process）是指正在运行的程序实例。由于多个进程可能需要共享数据或相互协作完成某些任务，因此需要一种方式来实现进程间的数据通讯。下面是几种常见的进程间数据通讯方式：

管道（Pipe）：管道是一种进程间通讯的机制，它可以在两个进程之间传递数据。一个进程写入数据到管道中，另一个进程从管道中读取数据。管道通常是一种半双工的通讯方式，即同一时间只能有一个进程进行读或写操作。管道有匿名管道和命名管道两种，匿名管道只能用于父子进程之间的通讯，而命名管道则可以用于任意进程之间的通讯。

消息队列（Message Queue）：消息队列是一种进程间通讯的方式，它是一种存放在内核中的消息链表。一个进程可以将消息发送到消息队列中，另一个进程可以从消息队列中读取消息。消息队列支持多个进程之间的通讯，并且可以进行同步和异步通讯。

共享内存（Shared Memory）：共享内存是一种进程间通讯的方式，它允许多个进程共享同一块内存区域。一个进程可以将数据写入共享内存，另一个进程可以从共享内存中读取数据。共享内存通常比管道和消息队列更高效，因为它不需要进行数据复制和内核空间和用户空间之间的数据传输。

信号量（Semaphore）：信号量是一种进程间同步的机制，它可以用于多个进程之间的互斥访问。一个进程可以通过信号量来获取对某个共享资源的访问权限，另一个进程必须等待该进程释放对该资源的控制权后才能获得访问权限。信号量可以用于控制多个进程之间的共享内存访问。

套接字（Socket）：套接字是一种进程间通讯的方式，它可以用于不同计算机之间的通讯。套接字通常用于网络编程，但也可以用于同一台计算机上的进程间通讯。

这些方式各有优缺点，根据具体的应用场景选择合适的通讯方式可以提高系统的性能和可靠性。

管道（Pipe）：管道通常用于父子进程之间的通讯，它的主要优点是实现简单，无需额外的系统资源和配置。但是管道只能用于单向通讯，即一个进程写入数据到管道中，另一个进程从管道中读取数据，因此无法进行双向通讯。此外，管道是基于内核空间的通讯方式，需要进行数据拷贝操作，因此通讯效率较低。

消息队列（Message Queue）：消息队列支持多个进程之间的通讯，可以进行同步和异步通讯。它的主要优点是可以实现数据存储，即可以将数据存放在消息队列中，另一个进程可以在合适的时间从队列中读取数据。此外，消息队列可以实现消息的优先级处理，对于某些特殊的应用场景非常有用。但是消息队列是基于内核空间的通讯方式，需要进行数据拷贝操作，因此通讯效率较低。

共享内存（Shared Memory）：共享内存允许多个进程共享同一块内存区域，因此通讯效率非常高。共享内存是一种无需内核介入的通讯方式，因此不需要进行数据拷贝操作。但是由于多个进程共享同一块内存，因此需要进行进程间同步，否则会导致数据混乱或者数据损坏。

信号量（Semaphore）：信号量是一种进程间同步的机制，可以用于多个进程之间的互斥访问。它的主要优点是可以实现进程间同步和互斥访问，对于一些需要共享资源的应用程序非常有用。但是信号量是基于内核空间的通讯方式，因此通讯效率较低。

套接字（Socket）：套接字通常用于不同计算机之间的通讯，但也可以用于同一台计算机上的进程间通讯。套接字的主要优点是可以实现跨机器通讯，因此非常灵活。但是套接字需要进行网络传输，因此通讯效率相对其他方式较低。

总体而言，不同的通讯方式各有优缺点，选择最合适的通讯方式取决于具体的应用场景。如果应用程序需要高效的通讯方式，可以选择共享内存或者套接字，但是需要考虑进程间同步和互斥访问的问题。如果应用程序需要简单的通讯方式，可以选择管道或者消息队列，但是需要考虑通讯效率较低的问题。如果应用程序需要实现跨机器通讯，可以选择套接字。

### 线程间有些什么样的同步方式，哪些情况下需要同步

在线程间进行协作时，由于多个线程可能同时访问共享资源，为了避免数据的竞争和不一致，需要对线程进行同步，以保证线程之间的顺序和正确性。以下是一些线程间同步的方式：

互斥锁：互斥锁是一种最常见的同步机制，可以保证同一时刻只有一个线程访问共享资源，其他线程需要等待。当一个线程获得了互斥锁，其他线程需要等待它释放锁后才能继续访问共享资源。互斥锁通常使用mutex来实现，可以使用pthread库或C++标准库等工具来创建和管理。

条件变量：条件变量是一种线程间同步的机制，允许一个线程等待另一个线程发出的通知，然后再继续执行。条件变量通常与互斥锁结合使用，可以使用pthread库或C++标准库等工具来创建和管理。

信号量：信号量是一种计数器，用来控制多个线程对共享资源的访问。当一个线程访问共享资源时，需要获取信号量并减少计数器，当它释放资源时，需要增加计数器并释放信号量。信号量可以用来实现线程间的互斥和同步。

屏障：屏障是一种同步机制，它可以使多个线程在某个点上等待，直到所有线程都到达该点后才能继续执行。屏障通常用于分阶段地执行任务，可以使用pthread库或C++标准库等工具来创建和管理。

原子操作：原子操作是一种不可中断的操作，可以保证对共享资源的访问是原子的，不会被其他线程中断。原子操作通常使用特殊的CPU指令来实现，也可以使用C++11的原子操作库来实现。

### 线程间死锁是怎么回事，怎样避免死锁

### MFC 序列化是什么意思

### 动态库和静态库有什么区别

动态库和静态库都是程序开发中常用的库文件形式，它们的主要区别在于链接方式和运行时的行为。

静态库（Static Library）是指在程序编译时将库文件的代码和数据复制到可执行文件中，使得可执行文件包含了库文件的全部内容，因此称为静态链接。当程序运行时，库文件的代码和数据已经被链接到可执行文件中，可以直接被操作系统加载并执行。静态库的优点是链接简单、使用方便、运行效率高，缺点是会导致可执行文件变大，而且如果多个程序使用同一个静态库，则会产生重复的代码，浪费系统资源。在Windows中，静态库文件的后缀通常为“.lib”。

动态库（Dynamic Library）是指在程序运行时才将库文件的代码和数据加载到内存中，因此称为动态链接。当程序需要使用库文件中的函数或数据时，操作系统会在内存中查找相应的库文件，并将它们加载到进程的地址空间中。动态库的优点是可执行文件变小，多个程序可以共享同一个库文件，节省系统资源，同时也便于更新和维护库文件，缺点是链接和加载的过程相对复杂，运行效率略低于静态库。Windows系统下的dll文件是动态链接库（Dynamic Link Library，缩写为DLL）文件，是一种常见的动态库文件形式。

总的来说，静态库适用于需要快速、高效、独立地运行的小型程序或单一模块，而动态库适用于需要共享、更新、维护和扩展的大型程序或复杂系统。在实际应用中，需要根据具体情况选择使用哪种类型的库文件。

[https://zhuanlan.zhihu.com/p/544022813?utm_id=0](https://zhuanlan.zhihu.com/p/544022813?utm_id=0)

### 什么是虚拟内存，虚拟地址空间，32位 PC 上虚拟地址空间多大，为什么是这么大

虚拟内存是一种计算机操作系统的内存管理技术，它将硬盘的部分空间用作临时的扩展内存，使得应用程序能够访问比物理内存更大的地址空间，从而提高了系统的性能和可靠性。

在虚拟内存技术下，每个进程被分配一个独立的虚拟地址空间，由操作系统来管理虚拟地址和物理地址之间的映射关系。当进程需要访问一个虚拟地址时，操作系统会根据该地址的映射关系，将其转换为一个物理地址，然后再将数据从内存中读取出来。如果该地址所对应的页面不在内存中，操作系统会将该页面从硬盘上的虚拟内存中读取出来，然后将其加载到内存中，并更新该虚拟地址的映射关系。当进程不再需要访问某个页面时，操作系统会将其从内存中移除，以释放内存空间。

虚拟内存技术的优点在于：

1. 允许应用程序访问比物理内存更大的地址空间，从而提高了系统的性能和可靠性。
2. 允许多个进程同时共享物理内存，从而节省了内存资源。
3. 允许操作系统在内存紧张时将不活动的页面交换到硬盘上，以释放内存空间。

虚拟内存技术的缺点在于：

1. 虚拟内存的管理和维护需要占用一定的系统资源和时间。
2. 虚拟内存的访问速度相对于物理内存会慢一些，因为需要经过地址映射和页面交换的过程。

在32位操作系统中，一个CPU指针的长度通常为32位（4个字节），因此它最多可以寻址2^32个不同的内存地址，即4GB的物理内存空间。虚拟内存的主要作用是让一个进程看起来好像拥有更多的内存，实现这个目标的方式是将进程的虚拟地址映射到物理内存或者磁盘上的虚拟内存页面。

为了让多个进程同时运行在32位操作系统上，操作系统需要为每个进程分配独立的虚拟地址空间，这些地址空间通常是相互独立的，每个进程都认为自己独占整个4GB的地址空间。然而，这并不意味着每个进程都可以使用4GB的物理内存。实际上，每个进程可以分配的物理内存大小是由可用物理内存和系统保留内存等因素所限制的，这通常会导致进程被迫使用虚拟内存页面来替换不常用的物理内存页面，从而降低系统的性能。

总之，32位操作系统的4GB地址空间是由CPU指针长度所限制的，虚拟内存的作用是在有限的物理内存下为进程提供更大的地址空间，但同时也会带来一定的性能开销。

64位操作系统的虚拟地址空间比32位操作系统要大得多，可以寻址的最大内存空间理论上为2^64个字节，即16EB（exabytes）。这是由于64位CPU指针的长度为64位，可以处理的地址空间范围更广。

然而，实际上，64位操作系统通常并不会为每个进程分配完整的2^64个字节的虚拟地址空间。相对于32位操作系统，64位操作系统能够更有效地利用物理内存，因此每个进程可以分配更多的物理内存，但仍然会有限制。在Windows和Linux系统上，通常会将虚拟地址空间限制在48位或者47位左右，即256TB或128TB。这样做主要是为了兼容性和效率考虑，因为64位地址空间的寻址范围太大，在实际应用中并不常见，而且为了兼容旧的32位程序，64位操作系统需要额外的兼容层，会带来一定的性能开销。

[在 4G 内存的机器上，申请 8G 内存会怎么样？_Young丶的博客-CSDN博客](https://blog.csdn.net/agonie201218/article/details/128948559)

### TCP 和 UDP 有什么区别，各自存在什么问题

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）都是网络协议，用于数据在网络中的传输。它们的主要区别如下：

1. 连接导向 vs 无连接：TCP是面向连接的协议，而UDP是无连接的协议。在TCP中，发送和接收方需要先建立一个连接，然后才能进行数据的传输。而在UDP中，发送方直接将数据包发送给接收方，不需要事先建立连接。
2. 可靠性：TCP提供可靠的数据传输，UDP不保证数据传输的可靠性。TCP使用确认和重传机制来确保数据的可靠传输。当发送方发送数据包后，接收方会发送一个确认包给发送方，告诉它已经成功接收数据。如果发送方在一定时间内没有收到确认包，就会重传数据包。而UDP不提供这些机制，发送方发送数据包后，就不会再去管它，接收方如果没有收到数据包，也不会重新发送。
3. 传输效率：UDP传输效率高于TCP。UDP没有连接的建立和断开的时间开销，也不需要确认和重传机制，因此传输效率高。而TCP的可靠性需要花费一定的时间来确认数据的传输，因此传输效率相对较低。
4. 数据量限制：UDP没有数据量限制，而TCP有数据量限制。UDP的数据包大小可以达到65535字节，而TCP因为要确保数据传输的可靠性，将数据分成多个报文段进行传输，每个报文段最大长度为MSS（最大段长），MSS的默认值为1460字节。
5. 应用场景：TCP适用于要求可靠传输、数据量较大的应用场景，比如文件传输、电子邮件等；而UDP适用于实时性要求较高、数据量较小的应用场景，比如音视频传输、网络游戏等。

总的来说，TCP提供可靠的连接，适用于对数据可靠性要求较高的场景，但传输效率较低；而UDP提供高效的数据传输，适用于实时性要求较高的场景，但传输过程中数据可能会丢失或重复。

## 三、设计和架构

### MVC 模式是什么

MVC模式是一种常用的软件设计模式，它将应用程序分成三个基本部分：模型（Model）、视图（View）和控制器（Controller），从而使应用程序的开发和维护变得更加容易。

模型（Model）表示应用程序的核心（比如一个数据库），它处理应用程序中的数据以及与数据相关的逻辑操作。视图（View）是模型的可视化呈现，提供用户界面以显示模型中的数据。控制器（Controller）处理用户输入，与模型和视图交互以完成用户请求的处理。

MVC模式的主要优点是它将应用程序的不同部分分离开来，使得每个部分都可以独立地开发、测试和维护。此外，由于MVC模式支持多个视图与一个模型的关联，因此它也提供了很好的扩展性和灵活性。

值得注意的是，MVC模式是一种通用的设计模式，可用于各种类型的应用程序，包括Web应用程序、桌面应用程序和移动应用程序。

### 举例知道的设计模式，单例，观察者，工厂，适配器，命令模式

1. 工厂模式（Factory Pattern）：工厂模式是一种创建型设计模式，用于创建对象，而无需向客户端暴露创建逻辑。这种模式通过调用工厂方法来实现。
2. 单例模式（Singleton Pattern）：单例模式是一种创建型设计模式，保证一个类只有一个实例，并提供一个全局访问点。这种模式通常被用于控制资源的访问，例如数据库连接池。
3. 观察者模式（Observer Pattern）：观察者模式是一种行为型设计模式，定义了一种一对多的依赖关系，使得多个观察者对象可以同时监听某一个主题对象，当主题对象发生改变时，所有依赖于它的观察者都会得到通知并自动更新。

工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们不直接创建对象，而是创建一个工厂类，根据需要，通过调用工厂类的方法来创建对象。这样做的好处是，如果需要修改对象的创建方式，我们只需要修改工厂类的方法即可，而不用修改所有使用到该对象的代码。

工厂模式通常包括一个抽象工厂类和若干个具体工厂类。抽象工厂类定义了一个创建对象的抽象方法，具体工厂类继承自抽象工厂类并实现了其方法。客户端代码只需要和抽象工厂类打交道，而不用关心具体的工厂类和对象创建的细节。这样，客户端代码与具体的实现解耦，提高了代码的可维护性和可扩展性。

工厂模式的优点包括：

1. 降低了代码的耦合性，客户端代码不需要知道具体的对象创建过程，只需要知道抽象工厂类的接口即可。
2. 可以在不修改客户端代码的情况下更改对象创建的方式。
3. 可以将对象创建的过程集中到一起，方便管理和维护。

工厂模式的缺点包括：

1. 增加了代码的复杂度，需要定义很多类和接口。
2. 对于简单的对象创建，工厂模式可能会显得过于复杂。

观察者模式（Observer Pattern）是一种软件设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。在该模式中，有两个重要的角色：被观察者和观察者。

被观察者是指一个对象，当它的状态发生改变时，需要通知其他对象（即观察者）。被观察者通常包含一个观察者列表，用于维护所有观察它的对象。它还包含添加、删除和通知观察者的方法。

观察者是指一个对象，当它观察到被观察者的状态发生改变时，需要执行相应的操作。观察者通常定义一个接口，包含一个更新方法，用于接收被观察者通知时所执行的操作。

通过使用观察者模式，可以使对象之间的关系更加松散，从而提高代码的灵活性和可重用性。例如，在一个GUI应用程序中，用户可以通过点击按钮或输入文本等方式改变应用程序的状态，而这些状态变化需要被其他的组件（例如显示器、计算器等）所感知并作出相应的响应。在这种情况下，可以使用观察者模式，将应用程序状态作为被观察者，将组件作为观察者，从而实现状态变化的通知和响应。

在 C# 中，观察者模式通常使用事件和委托来实现。具体地，被观察者定义一个事件（Event）以及触发事件的委托（Delegate），观察者实现一个事件处理器（Event Handler）来处理被观察者触发的事件。这样一来，被观察者就可以通过事件来通知观察者，而观察者只需要注册事件处理器即可接收到被观察者的通知。

C++没有Event和Delegate，但可以使用函数指针和回调函数来实现观察者模式。具体地，定义一个抽象基类（通常称为Subject），其中包含注册观察者、删除观察者和通知观察者等方法。观察者类需要实现一个抽象接口（通常称为Observer），其中包含被通知时所需要执行的方法。在Subject类中，维护一个观察者列表，当状态改变时，遍历列表，通知每个观察者。

适配器模式（Adapter Pattern）是一种结构型设计模式，它将一个类的接口转换成客户端所期望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式主要分为类适配器模式和对象适配器模式。

类适配器模式使用多重继承的方式，使得适配器类既继承了目标抽象类（或接口），又继承了被适配者类，从而将两个不兼容的接口统一起来。对象适配器模式则是通过组合的方式，将一个已有的对象包装起来，使得它的接口能够与目标接口兼容。

适配器模式的优点包括：

- 使得原本不兼容的类能够一起工作，提高了类的复用性。
- 可以通过适配器来修改已有的类的接口，而无需修改其源代码。
- 可以将多个类的功能组合到一个类中，从而减少了代码的复杂度。

适配器模式的缺点包括：

- 如果使用不当，可能会增加代码的复杂度，使得程序更难以理解和维护。
- 在使用类适配器模式时，如果被适配者类的接口发生了改变，可能会导致适配器类也需要做出相应的改变，增加了维护成本。

## 四、语言

### C++静态变量、全局遍历、局部变量和 new 出的对象都是在哪一块内存上，各自生命期

### 有没有不能用\==做相等比较的数据，如果就希望用\==做比较该怎么做

在C++中，使用 == 进行比较时，会比较两个值的精确二进制表示。对于某些类型，例如 float 和 double，由于浮点数表示的精度有限，它们的精确值可能无法用二进制表示，从而导致比较结果不准确。因此，这些类型的比较通常需要使用一些特定的函数或技巧来避免精度误差。

除了浮点数类型之外，还有一些其他类型也不能使用 == 进行比较，比如指针类型。因为指针实际上是一个内存地址，如果使用 == 进行比较，它只会比较两个指针是否指向同一个内存地址，而不会比较它们所指向的内容是否相同。因此，在比较指针所指向的内容时，应该使用特定的比较函数，例如 std::equal_to。

如果你坚持要用 == 来比较两个浮点数，你可以使用一些方法来尽量避免精度误差，例如：

1.使用比较小的精度差来比较：例如，如果你只需要比较到小数点后两位，那么可以将两个数都乘以 100 并转为整数进行比较。

2.使用浮点数库：有一些第三方的浮点数库（如 Boost.Math 和 GMP）提供了更加精确的浮点数计算方法。

3.使用误差范围比较：相比于直接比较，使用一个误差范围（如相差小于某个值）来比较更为合适，例如：

`double a = 0.1 + 0.2;`

`double b = 0.3;`

`double epsilon = 0.00001;`

`if (abs(a - b) < epsilon) {`

    `// a 和 b 在指定误差范围内相等`

`}`

请注意，这种比较方式仍然不是完全准确的，因为某些数值仍然可能超出误差范围，但相比于直接使用 == 来说更为稳健。

### 常量和宏有什么差异

C++中常量（Constants）和宏（Macros）都可以用于表示一些固定的值，但是它们之间有一些差异。

常量是一种类型安全的定义方式，通常使用const关键字来定义，它可以被编译器检查，避免了一些潜在的错误。常量的值是在编译时确定的，因此在运行时不会改变。常量通常会占用内存空间，但是编译器会尝试优化常量的使用，比如在编译时直接将常量值替换到代码中。下面是一个使用常量的例子：

const int Max = 100;

int arr[Max];

宏是一种预处理器定义的符号常量，通常使用#define关键字来定义，它是一种简单的文本替换机制。宏的值是在预处理时进行文本替换得到的，因此在编译时无法检查宏的正确性。宏不会占用内存空间，因为它只是一个文本替换。下面是一个使用宏的例子：

#define Max 100

int arr[Max];

总的来说，常量比宏更加安全和可维护，而宏的主要优点是能够进行更加灵活的编程和预处理操作。

### 智能指针是什么，原理

### 内联函数有什么好处

C++中的内联函数是一种函数定义方式，用 inline 关键字来修饰函数，表示该函数在编译时应该被直接展开，而不是按照常规的函数调用方式来执行。

内联函数的优势主要有以下几点：

1. 执行效率高：由于内联函数的展开是在编译期完成的，所以在运行时直接执行展开后的代码，避免了函数调用的开销，从而提高了执行效率。
2. 函数体短小：通常情况下，内联函数的函数体应该足够小，否则编译器可能不会将其展开，从而失去了内联函数的优势。
3. 避免宏定义：内联函数是一种更加优雅和安全的宏定义方式，避免了宏定义中可能出现的一些问题，比如宏定义中的副作用等。内联函数和宏函数的作用是相似的，都是用来在编译期间直接展开代码，避免了函数调用的开销，提高程序的运行效率。不过内联函数的好处在于它具有函数的
4. 类型检查和作用域规则，而且也不存在宏函数的一些问题，比如语法错误、宏定义嵌套等等。同时，内联函数也不需要使用预处理器，使代码更加清晰易懂。

需要注意的是，内联函数的使用应该谨慎，不是所有函数都适合用内联函数来定义，否则可能会对代码的可读性和可维护性造成一定的影响。

### 什么是虚函数，C++用什么样的机制来保证调用到正确的虚函数

在C++中，虚函数是一种特殊的成员函数，它可以被派生类重写。当使用基类指针或引用来调用虚函数时，程序会根据指针或引用指向的实际对象类型来决定调用哪个版本的虚函数，即实现了动态绑定。

为了定义虚函数，需要在函数声明前加上virtual关键字，这告诉编译器该函数是虚函数。派生类中重写虚函数时，也需要在函数声明前加上virtual关键字。

当调用虚函数时，编译器并不知道最终调用的是哪个函数，因为这个函数是在运行时才确定的。因此，编译器会为类创建一个虚函数表（vtable），该表是一个包含指向虚函数的指针的数组。

在类的对象中，编译器会添加一个指向虚函数表的指针，称为虚函数指针（vptr）。当调用虚函数时，编译器会根据对象的虚函数指针找到它所属的虚函数表，然后通过函数的偏移量在虚函数表中查找相应的函数指针。

需要注意的是，虚函数指针只在对象被创建时进行初始化，因此它只能指向对象所属的类的虚函数表。如果派生类中覆盖了基类的虚函数，那么派生类会有自己的虚函数表，但对象的虚函数指针不会改变，仍指向基类的虚函数表。因此，如果通过基类指针或引用调用虚函数，会调用基类的虚函数；如果通过派生类指针或引用调用虚函数，会根据虚函数表调用派生类的虚函数。

虚函数是C++中实现多态性的一种重要手段。通过使用虚函数，可以在基类中定义一个通用的函数接口，让派生类去实现不同的行为，从而实现多态性。

static_cast和dynamic_cast有什么区别

当我们需要进行类型转换时，C++ 中有几种转换方式，包括 static_cast、dynamic_cast、reinterpret_cast 和 const_cast 等。其中，static_cast 和 dynamic_cast 都可用于具有继承关系的指针或引用类型之间的转换，它们的区别如下：

- static_cast：主要用于基本数据类型（如 int、float 等）之间的转换，或者具有继承关系的指针或引用类型之间的转换（向上转型或向下转型），但是只能在编译时检查类型安全，不能检查运行时类型安全。
- dynamic_cast：主要用于具有继承关系的指针或引用类型之间的转换（向上转型或向下转型），但只能转换指向具有虚函数的类的指针或引用类型，并且在运行时动态检查类型安全，如果类型转换不安全，则返回空指针。

举个例子，假设有如下代码：

class Base {

public:

    virtual void foo() {}

};

class Derived : public Base {

public:

    void foo() {}

};

int main() {

    Base* b = new Derived;

    Derived* d = static_cast<Derived*>(b);

    Derived* d2 = dynamic_cast<Derived*>(b);

}

在这个例子中，static_cast 将 Base 类型的指针 b 转换为 Derived 类型的指针 d，这是合法的转换，因为 Base 是 Derived 的基类，但是并没有运行时的类型检查，因此不保证类型安全。而 dynamic_cast 也将 Base 类型的指针 b 转换为 Derived 类型的指针 d2，但是它会在运行时动态检查类型安全，因此如果类型转换不安全，将返回空指针。

需要注意的是，dynamic_cast 的效率相对较低，因为它需要进行运行时类型检查，而 static_cast 只需要进行编译时类型检查。因此，在进行类型转换时，应尽量使用 static_cast，只有在必要的情况下才使用 dynamic_cast。

### IOS autorelease 和 release 有什么区别

### C# GC 是根据什么判断对象无效

在 C# 中，GC（垃圾回收）通过“引用计数”和“可达性分析”两种方式来判断对象是否无效。

1. 引用计数：当一个对象被创建时，会在对象头部记录该对象的引用计数器，每当有一个引用指向该对象时，引用计数器就会加1，每当有一个引用离开作用域或被设置为 null 时，引用计数器就会减1。当引用计数器的值为 0 时，该对象就不再被使用，可以被 GC 回收。这种方式的缺点是无法解决循环引用的问题，因为循环引用的对象的引用计数器永远不会为 0。
2. 可达性分析：GC 通过可达性分析算法来判断哪些对象是“可达”的，也就是哪些对象可以通过根对象（比如全局变量、静态变量等）访问到。如果一个对象不可达，则认为它已经成为垃圾，可以被 GC 回收。这种方式能够解决循环引用的问题，但是需要耗费一定的时间进行分析。

在实际应用中，C# 的 GC 一般采用第二种方式，即可达性分析算法，因为它能够解决循环引用的问题，并且在大多数情况下也不会太耗费时间。

### C# 值类型有哪些 ？引用类型有哪些

在C#中，值类型（Value Types）是一种直接存储其值的数据类型，而不是存储其引用的数据类型。以下是C#中的一些常见的值类型：

1. 整型（Integral Types）：包括整数类型，如sbyte、byte、short、ushort、int、uint、long和ulong，它们分别表示有符号8位、无符号8位、有符号16位、无符号16位、有符号32位、无符号32位、有符号64位和无符号64位整数。还有字符型（Char）：表示单个Unicode字符。它分类为整形，但无法将其他类型隐式转换为 char 类型，且char必须将类型的常量作为 character_literal 写入。
2. 浮点型（Floating Point Types）：包括float和double，它们分别表示32位和64位的浮点数。
3. 十进制型（Decimal）：表示一个固定精度的数值类型，通常用于财务和货币计算。
4. 布尔型（Boolean）：表示布尔值（true或false）。
5. 枚举型（Enum）：表示一组命名的整数常量。

在 C# 中，常见的引用类型包括类、接口、委托、数组等等。它们的实例都是通过引用进行访问的，而不是直接存储在变量中。

具体来说：

- 字符串（string）是一种引用类型，表示一组字符序列。
- 接口（interface）是一种引用类型，用于定义一个类应该具有哪些方法和属性，但不提供具体实现。接口的实现通常通过类来实现。
- 类（class）是一种引用类型，用于创建对象。类的实例通常是通过关键字 new 来创建的。
- 委托（delegate）是一种引用类型，用于引用一个或多个方法。委托可以看作是函数指针的一种高级形式。
- 数组（array）是一种引用类型，用于存储同一类型的多个值。数组的大小在创建时指定，且不能更改。

除此之外，还有许多其他的引用类型，如枚举（enum）、结构体（struct）、动态对象（dynamic）等。

object类类型是所有其他类型的最终基类。 C # 中的每个类型都直接或间接从 object 类类型派生。

关键字 object 只是预定义类的别名 System.Object 。

### 什么是装箱和拆箱

在 C# 中，[[装箱]]（boxing）和[[拆箱]]（unboxing）指的是将值类型转换为引用类型的过程，以及将引用类型转换为值类型的过程。这两个过程通常用于将值类型存储在堆上，或者从堆中获取值类型。在装箱时，值类型的值被封装在一个对象中，这个对象是一个引用类型。在拆箱时，将对象中封装的值类型的值提取出来，重新转换为值类型。

例如，将一个 int 类型的值类型装箱到 object 类型的引用类型中，可以使用以下代码：

`inti= 42; objecto= i; // 装箱`

将一个 object 类型的引用类型拆箱成 int 类型的值类型，可以使用以下代码：

`objecto = 42; inti = (int)o; // 拆箱`

装箱和拆箱是因为C#的类型系统是分为值类型和引用类型的。值类型在内存中占据的是一段连续的空间，而引用类型在内存中只占据了一个指针的空间。在某些情况下，需要将值类型当作引用类型使用，例如当需要将值类型存储在集合类中（如ArrayList、List<T>）时，需要将值类型转换为引用类型。这个过程就是装箱。而当需要从集合类中取出一个值类型的元素时，需要将引用类型转换为值类型，这个过程就是拆箱。

装箱和拆箱都需要进行数据的类型转换和内存的分配和释放，因此会产生一定的性能开销。在进行频繁的装箱和拆箱操作时，会对性能产生较大的影响。因此，尽量避免频繁进行装箱和拆箱操作，可以使用泛型类型和委托等技术来避免这种情况的发生。

装箱和取消装箱的概念是 c # 类型系统的核心。 它通过允许将任何 value_type 值转换为类型或从类型转换，来在 value_type s 和 reference_type 之间提供桥梁 object 。 装箱和取消装箱可实现类型系统的统一视图，其中，任何类型的值最终都可以被视为对象。

装箱是将[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)转换为 object 类型或由此值类型实现的任何接口类型的过程。 常见语言运行时 (CLR) 对值类型进行装箱时，会将值包装在 [System.Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 实例中并将其存储在托管堆中。 取消装箱将从对象中提取值类型。 装箱是隐式的；取消装箱是显式的。 装箱和取消装箱的概念是类型系统 C# 统一视图的基础，其中任一类型的值都被视为一个对象。

下例将整型变量 i 进行了装箱并分配给对象 o。

`int i = 123;`

`// The following line boxes i.`

`object o = i;`

然后，可以将对象 o 取消装箱并分配给整型变量 i：

`o = 123;   i = (int)o;  // unboxing`

相对于简单的赋值而言，装箱和取消装箱过程需要进行大量的计算。 对值类型进行装箱时，必须分配并构造一个新对象。 取消装箱所需的强制转换也需要进行大量的计算，只是程度较轻。 有关更多信息，请参阅[性能](https://learn.microsoft.com/zh-cn/dotnet/framework/performance/performance-tips)。

### 委托是什么

委托（Delegate）是一种引用方法的类型，它可以在运行时动态地绑定到任何方法，而且一旦绑定就可以像其他函数一样调用这个方法。委托可以看做是函数的一个抽象，它可以接收不同的函数作为参数，也可以返回函数。

在 C# 中，委托可以用于事件处理、回调函数等场景，例如当一个事件发生时，需要调用一个或多个方法进行处理，这时就可以使用委托来实现事件处理程序。另外，C# 中的 lambda 表达式也可以被转换为委托，使得代码更加简洁易读。

System.Action 和 System.Func 都是 C# 中预定义的委托类型。它们与自定义委托类型的区别在于，它们已经定义好了委托签名，可以直接使用，而无需自己再定义一个委托类型。

具体而言，System.Action 是一种无返回值的委托类型，而 System.Func 则是一种有返回值的委托类型。它们都可以用来代替自定义委托类型，从而简化代码。例如，可以使用 System.Action 来表示一个没有参数和返回值的方法，或者使用 System.Func 来表示具有一个或多个参数和返回值的方法。

当一个类定义了一个委托类型的成员变量，并且该委托变量被公开成public时，其他类实例可以直接访问和调用该委托变量，而不需要使用该类实例的引用。这可能会导致在类的实现中无法控制委托变量的使用，从而导致潜在的安全风险和错误。

例如，如果一个类定义了一个委托类型的成员变量，可以被外部类访问并添加方法到该委托中。这样，外部类就可以调用该委托来执行其添加的方法，而且该类本身无法控制这些方法的实现。这可能导致安全问题，例如调用未经授权的方法或者访问未经授权的数据。

因此，在实现中，可以采取一些方法来防止在类外部直接调用委托，例如：

- 将委托变量声明为private或protected，只允许在类内部使用。
- 通过实现包装器方法来控制委托变量的调用和使用。
- 将委托变量封装在属性中，并通过属性访问委托变量。

这些方法可以帮助避免委托变量被外部类误用，从而提高代码的安全性和可靠性。

事件可以被认为是一种委托的“包装器”，它可以防止在类外部直接调用委托，并且可以提供更高的安全性和更严格的访问控制。在使用事件时，类定义一个事件，其他类可以订阅该事件并提供处理程序方法，当事件被触发时，处理程序方法将被调用。

事件的定义类似于委托的定义，但使用关键字“event”，例如：

`public event EventHandler MyEvent;`

在事件定义中，可以指定事件处理程序的委托类型。例如，在上面的代码中，使用了EventHandler委托类型，它是一个预定义的委托类型，用于处理事件数据。

然后，在类的内部可以使用“+=”运算符将事件处理程序添加到事件中，例如：

`MyEvent += newEventHandler(MyEventHandler);`

这将添加一个名为“MyEventHandler”的方法作为事件的处理程序。当事件被触发时，将调用这个方法。

在类的外部，可以使用“+=”和“-=”运算符来订阅和取消订阅事件，例如：

`myObject.MyEvent += newEventHandler(MyEventHandler);`

`myObject.MyEvent -= newEventHandler(MyEventHandler);`

这些运算符将在事件中添加或删除委托，以便在事件被触发时调用或不调用相应的方法。

可以这样理解：

- Delegate是一种类型，用于定义函数签名，可以用来声明委托变量。
- Event是一种委托变量的特殊类型，它只能通过+=和-=操作符来订阅和取消订阅事件，可以用于事件的触发和处理。
- Action和Func是.NET Framework提供的两种预定义的委托类型，用于快速创建委托实例，Action用于表示没有返回值的方法，Func用于表示有返回值的方法。它们本质上就是一些预定义的Delegate类型，所以也可以被用作委托变量的类型。

可以这样认为，Event就是一种委托变量的“限制版”，它只允许订阅和取消订阅事件，而不允许在类外部直接调用委托。而Action和Func是Delegate的两个派生类，它们提供了一些常用的函数签名，可以快速创建委托实例，方便编程。

### 什么样的对象可以通过 foreach 遍历

在 C# 中，foreach 可以用于遍历实现了 IEnumerable 或 IEnumerable<T> 接口的对象。IEnumerable 表示枚举器（enumerator）对象，而 IEnumerable<T> 表示强类型枚举器对象。实现这些接口的类型必须提供一个 GetEnumerator() 方法，该方法返回一个可用于枚举序列的对象。

通常，可以使用 foreach 遍历集合类（如 List<T>、Dictionary<TKey, TValue>、HashSet<T> 等）以及数组等类型。当然，也可以自己定义一个类，实现 IEnumerable 或 IEnumerable<T> 接口，以便使用 foreach 遍历自定义类型的实例。

## 五、图形学和引擎

### 一个变换矩阵是哪些变换组成

### 3D 变换流程，什么是深度，深度还有些什么额外的作用

### 骨骼动画的原理

### 光源的分类，环境光，方向光，点光

### 光照的计算

### 什么是一个物件的材质，包含哪些东西

### 场景数据结构

在Unity中，场景数据结构主要是由Scene、GameObject、Component和Transform等组成的。

1. Scene（场景）：表示场景的数据结构，可以看作是一组GameObject的集合，保存了场景中所有GameObject的信息，包括其位置、旋转、缩放、组件等。
2. GameObject（游戏对象）：表示游戏中的对象，可以包含多个组件，例如Transform、Mesh Renderer、Rigidbody等。
3. Component（组件）：表示GameObject的部分功能，例如Transform组件负责控制位置、旋转、缩放等信息，Mesh Renderer组件负责渲染3D模型等。
4. Transform（变换）：表示游戏对象的位置、旋转和缩放等变换信息，每个GameObject都有一个Transform组件，它可以用来控制GameObject的位置、旋转和缩放等信息。

在Unity中，场景的组织方式是通过树形结构来实现的。每个Scene都有一个根节点，称为Root GameObject，所有的GameObject都是Root GameObject的子节点。这样就形成了一个GameObject树的结构，可以用来组织和管理场景中的所有对象。每个GameObject都可以有自己的子GameObject，这样就可以形成多层级的结构。

GameObject和Component可以在运行时被动态添加、删除和修改，这使得开发者可以方便地创建和管理游戏对象和组件。而Transform组件则可以控制GameObject的位置、旋转和缩放等变换信息，使得游戏对象可以随时改变自己的状态。

### 相机裁剪

在Unity中，相机裁剪（Camera Frustum Culling）是一种优化技术，用于在渲染场景时只渲染相机视锥内的物体，从而减少渲染的数量，提高渲染效率。

相机视锥是一个可见的体积，其形状是一个截锥体。只有在该视锥体内的物体才会被渲染。当相机视野发生变化时，Unity会自动计算出新的视锥体。相机视锥包括近裁剪面、远裁剪面、左右裁剪面、上下裁剪面。

相机裁剪可以通过多种方式实现，其中一种常见的方法是使用Bounding Volume（包围盒）来进行判断。Bounding Volume是一种简单的几何形状，比如球体、立方体、胶囊体等，用来包围场景中的物体。通过比较物体的Bounding Volume和相机的视锥体，可以确定物体是否在视锥体内。

Unity中提供了一些API来支持相机裁剪，比如Camera类的cullingMask属性可以用于指定相机渲染的物体层级，以及layerCullDistances属性可以用于设置相机渲染不同距离的物体的距离范围等。此外，还可以使用自定义的Shader来实现更复杂的相机裁剪。

Unity各个文件夹的作用Resource、Editor、StreamingAssets

### Unity 协程

在Unity中，协程是一种特殊的函数，可以在其执行期间暂停和继续执行，而不会阻塞其他的代码。协程可以使得复杂的异步操作变得更加简单，并且可以在游戏中创建延时效果和动态变化的效果。

Unity中的协程使用C#的迭代器实现，可以使用yield语句来控制协程的执行。在使用yield语句时，可以指定暂停的时间，也可以等待一个异步操作的完成，例如加载场景或者等待玩家的输入等。

协程在Unity中广泛应用于以下方面：

- 控制动画播放：协程可以在特定的时间间隔内控制动画的播放，从而实现动态变化的效果。
- 延时效果：协程可以在一定的时间间隔之后再执行代码，从而实现延时效果。
- 异步操作：协程可以等待异步操作的完成，例如加载场景、下载文件等。
- 协同作用：协程可以和其他协程协同作用，从而实现更加复杂的异步操作。

在Unity中，可以使用StartCoroutine()函数来启动协程，也可以使用StopCoroutine()函数来停止协程的执行。同时，Unity也提供了许多常用的协程函数，例如WaitForSeconds()、WaitForFixedUpdate()、WaitForEndOfFrame()等，可以使得协程的编写更加方便和简单。

### MeshRender 中 material 和 sharedmaterial

[Mesh中 material 和 sharedMaterial 的区别及内部实现的推断_魔小明的博客-CSDN博客](https://blog.csdn.net/David_Dai_1108/article/details/71598628)

### NGUI 的 Panel 有什么用

[Meshes, Materials, Shaders and Textures - Unity Manual (unity3d.com)](https://docs.unity3d.com/ru/2019.4/Manual/Shaders.html)

### 怎样判断两个向量垂直

### 导航网格 （Navigation Mesh）

[Unity 中的导航系统 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/2021.2/Manual/nav-NavigationSystem.html)

导航系统可让您创建能够在游戏世界中导航的角色。该系统让角色能够理解自身需要走楼梯才能到达二楼或跳过沟渠。Unity 导航网格 (NavMesh) 系统包含以下部分：

导航网格（即 Navigation Mesh，缩写为 NavMesh）是一种数据结构，用于描述游戏世界的可行走表面，并允许在游戏世界中寻找从一个可行走位置到另一个可行走位置的路径。该数据结构是从关卡几何体自动构建或烘焙的。

导航网格代理 (NavMesh Agent) 组件可帮助您创建在朝目标移动时能够彼此避开的角色。代理使用导航网格来推断游戏世界，并知道如何避开彼此以及移动的障碍物。

网格外链接 (Off-Mesh Link) 组件允许您合并无法使用可行走表面来表示的导航捷径。例如，跳过沟渠或围栏，或在通过门之前打开门，全都可以描述为网格外链接。

导航网格障碍物 (NavMesh Obstacle) 组件可用于描述代理在世界中导航时应避开的移动障碍物。由物理系统控制的木桶或板条箱便是障碍物的典型例子。障碍物正在移动时，代理将尽力避开它，但是障碍物一旦变为静止状态，便会在导航网格中雕刻一个孔，从而使代理能够改变自己的路径来绕过它，或者如果静止的障碍物阻挡了路径，则代理可寻找其他不同的路线。

### 高斯模糊

### ShadowMap

### SSR 和 Deferred Lighting 的性能瓶颈

[https://www.quora.com/How-do-you-explain-the-differences-among-static_cast-reinterpret_cast-const_cast-and-dynamic_cast-to-a-new-C++-programmer](https://www.quora.com/How-do-you-explain-the-differences-among-static_cast-reinterpret_cast-const_cast-and-dynamic_cast-to-a-new-C++-programmer)