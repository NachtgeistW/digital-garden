
设计模式是一种在软件设计中用于解决特定问题的通用可重用解决方案。它不是可以直接转换成代码的完成设计，而是对在特定场景中如何解决问题的描述或模板。设计模式可以提高开发人员的效率，因为它们提供了已经在实践中经过验证的解决方案。

设计模式并不直接关注语言语法或代码，而是关注解决问题的策略和方法。这也是为什么它们可以在不同的编程语言和框架中使用。

## **五如何在实际编程中应用设计模式**

### 5.1 **设计模式的选择与使用**

在实际编程中，选择和使用设计模式应根据问题的具体需求和上下文。并非所有的设计模式都适用于所有的情况，使用不当的设计模式可能会导致代码更加复杂，而不是简化设计。一些有效的选择和使用设计模式的建议包括：

- 明确需求：在开始设计之前，明确你试图解决的问题和你的目标是什么。这将帮助你选择最适合的设计模式。
- 理解模式：每个设计模式都有其特定的使用场景。理解每个设计模式的目的和适用性，可以帮助你做出合适的选择。
- 避免过度设计：并非所有的问题都需要使用设计模式来解决。在一些情况下，简单的设计可能更为有效。

### 5.2 **设计模式的优点与缺点**

设计模式的优点主要包括：

- 提高代码可复用性：设计模式提供了标准的、已被证明有效的方法来解决常见的设计问题，可以提高代码的可复用性。
- 提高代码可维护性：设计模式提供了清晰的结构和描述，可以使代码更易于理解和维护。
- 提高代码的可扩展性：设计模式通常考虑到了系统可能的变化，使得系统更易于扩展。

设计模式的缺点主要包括：

- 增加了代码的复杂性：不恰当的使用设计模式可能会导致代码更加复杂。
- 可能导致过度工程：过度使用设计模式可能导致过度工程，即对简单问题采用过于复杂的解决方案。

### 5.3 **设计模式的实践案例**

实际的设计模式使用案例可以参考各种开源项目。例如，Java的集合框架就广泛使用了迭代器模式；Spring框架中使用了工厂模式和代理模式；React库使用了观察者模式等。通过学习和分析这些项目中的代码，可以更深入地理解如何在实际项目中应用设计模式。
## 常用的 23 种设计模式

## 创建模式

创建模式全部是关于如何创建实例的。这组模式都提供一个方法，将客户端从所需实例的类中解耦。

它们可以被划分为两组：类创建模式及对象创建模式。类创建模式在实例化过程中有效地使用类之间的继承关系，对象创建范模式则使用代理来完成其任务。

### 2.1 **[[单例模式]]**

单例模式确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。比如，[数据库连接池](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0&spm=1001.2101.3001.7020)、日志记录器等都可以使用单例模式，以确保资源的统一和节省。

### 2.2 **[[建造者模式]]**

建造者模式用于创建复杂对象的一种设计模式。它允许你在不改变整个对象的代码的情况下生产出不同的对象，或者在不露出对象创建过程的情况下创建步骤。

### 2.3 **[[原型模式]]**

原型模式是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。在JavaScript中，由于其支持基于原型的继承，所以原型模式被广泛使用。

### 2.4 **[[工厂方法]]**

工厂方法模式提供了一个接口，该接口由子类决定实例化哪一个类。这使得在类的子类化中，指定实例化过程变得容易。

### 2.5 **[[抽象工厂]]**

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。这可以用于任何需要动态实现的平台独立的代码。

## 结构模式

结构型模式涉及到类和对象的组合方式，用于创建更大的结构。

### 3.1 **[[适配器模式]]**

适配器模式用于将一个类的接口转换为客户端期望的另一种接口。适配器让原本接口不兼容的类可以一起工作。这对于处理老系统和新系统的兼容性问题特别有用。

### 3.2 **[[桥接模式]]**

桥接模式把抽象和实现分离，使它们可以独立变化。这种模式有助于减少代码重复，并允许你分离关注点，使你的代码更易于管理和优化。

### 3.3 **[[组合模式]]**

组合模式让你可以使用树形方式构建对象，其中每个节点可能是复合的（一个包含子节点的树枝）或者叶子（一个没有子节点的节点）。这种模式让客户端能够统一对待复合和单一对象。

### 3.4 **[[装饰者模式]]**

装饰者模式允许你在运行时动态地改变对象的行为。这对于需要在运行时进行特殊处理的场景非常有用。

### 3.5 **[[外观模式]]**

外观模式提供了一个统一的接口，用于访问子系统中的一组接口。外观定义了一个更高级的接口，使得子系统更易于使用。

### 3.6 **[[享元模式]]**

享元模式尽可能减少内存使用，共享大量细粒度的对象。这在处理大量类似对象时特别有用，例如游戏中的NPC、粒子系统等。

### 3.7 **[[代理模式]]**

代理模式为其他对象提供一个代理以控制对这个对象的访问。这用于延迟加载、访问控制、分布式访问等场景。

结构型模式有助于确保代码易于理解，且易于维护和扩展。它们提供了强大的工具，以便更好地控制代码的结构。在接下来的部分，我们将探讨更多关于如何使用和实现这些模式的信息。

## 行为型模式

行为型模式涉及到对象间的职责分配，它们定义了对象如何交互，以及划分了对象的职责。

### 4.1 **[[责任链模式]]**

责任链模式创建了一个对象链，每个对象都有机会处理请求，从而解耦了请求的发送者和接收者。这种模式通常用在处理流程或命令流程中。

### 4.2 **[[命令模式]]**

命令模式将请求封装为一个对象，这样可以使用不同的请求对客户进行参数化。这种模式在需要回滚操作或者将操作记录到日志中的场景非常有用。

### 4.3 **[[解释器模式]]**

解释器模式为解释语言的语法提供了一个解释器。这种模式常用在编译器和解析工具中。

### 4.4 **[[迭代器模式]]**

迭代器模式提供了一种方法来顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。这对于处理集合数据非常有用。

### 4.5 **[[中介者模式]]**

中介者模式定义了一个封装一组对象如何交互的对象。这种模式将系统分解为一组松散耦合的对象，从而提高系统的可扩展性。

### 4.6 **[[备忘录模式]]**

备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复为先前的状态。这在处理撤销操作或者保存状态的场景非常有用。

### 4.7 **[[观察者模式]]**

观察者模式定义了对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

### 4.8 **[[状态模式]]**

状态模式允许一个对象在其内部状态改变时改变它的行为。这种模式可以使一个对象的行为看起来好像修改了它的类。

### 4.9 **[[策略模式]]**

策略模式定义了算法家族，分别封装起来，让它们之间可以相互替换，让算法的变化不影响到使用算法的客户。

### 4.10 **[[模板方法模式]]**

模板方法模式定义了一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

### 4.11 **[[访问者模式]]**

访问者模式主要将数据结构与数据操作分离，允许一个或多个操作应用于一组对象，解决数据结构和作用于结构上的操作之间耦合度的问题。

